%!TEX root=../thesis.tex
\chapter{Introduction} \label{cha:intro}

In the last few years companies are putting a huge effort in developing a wide
variety of web frameworks to create Graphical User Interfaces (GUIs). This trend
of integrating GUIs into web browsers is constantly growing and it can be
confirmed by the success of Facebook's React~\cite{fbreact} and Google's
AngularJS~\cite{angularjs}. These are probably the two most used frameworks across
web developers, since they allow them to create responsive and nice-looking products.

Talking about the embedded world, most of the software have its own GUI
written in a native programming language that is often the same throughout the entire application.
One of the most common examples is Java~\cite{gosling1995java}, which makes use of the JavaFX
platform or the Swing toolkit to build the graphics.\\
What may sound surprising at a first glance is the continuously increasing trend of 
building user interfaces taking advantage of web technologies.
They allow to prototype and design UIs very quickly and, in
most of the cases, they give also better look and feel with respect to native graphics.
A very good example of integration of such technologies is NASA's Open MCT~\cite{openmct}.
OpenMCT is a ``next-generation mission control software developed both for desktop and mobile
usage''. It has been used for mission planning and operations in the Resouce 
Prospector mission~\cite{andrews2014introducing} at NASA's Research Center as well as for
data analysis of spacecraft missions. This software is clearly the evidence that web
technologies have a huge potential that goes beyond the mere website development and that they 
can be applied to deliver also highly critical services.
Another kind of web application that is becoming very popular is 2D and 3D map navigators.
Let us think about the technologies composing the core of very successfull products like
Google Maps, Microsoft's Bing Maps and OpenStreetMap.\\
Given the fact that running UIs inside a browser window is gaining popularity both inside the
developers community and the corporate world, the main aspect that has to be analyzed
in detail is the kind of performance that can be delivered and guaranteed. This is probably one of
the hardest tasks a developer has to face building web applications. Finding bugs
and bottlenecks inside the code can be a draining and tricky activity due to the huge number
of components and layers involved to keep the application up and running. Furthermore,
being able to prove that a web application respects some kind of temporal constraint
is even harder or, in some case, impossible. Hence, the main aim of this thesis is
to build an analysis framework able to address this problem and to study in detail
if high intensive graphical web application can respect temporal constraints.

The test application developed and extensively analyzed in this work is a 3D navigator.
This capability is one of the main requirements for the ACANTO~\cite{acanto}
project\footnote{This project has received funding from the European Union’s Horizon
2020 research and innovation programme - Societal Challenge 1 (DG CONNECT/H) under 
grant agreement No 643644.}, more specifically as part of the user interface driving
the FriWalk robotic walker.
The main goal of ACANTO is to study and develop an effective strategy to fight the
physical and cognitive decline of older adults facing limited financial
resources for health care and social services. This is achieved by means of FriWalk,
a robotic walking assistant that supports the user in its daily activities requiring
physical exercise. Furthermore, the system has to reccomend activities selected 
by a senior user (eg. a doctor) to the user.

Being able to state whether graphics technologies are actually performing well for
a specific real-time application is not an easy task.
Some attention has been paid to the real-time capabilities of the mainstream window
syetems and more specifically to X11. X11 is not aware of the real-time priorities
of the tasks asking the server to paint on the screen. Thus, real-time
tasks can suffer of blocking time from lower priority tasks when they need to
interact with the window system, making difficult or even impossible to find an
upper bound for the blocking time. Furthermore a mainstream window system like X11
is conceived to manage heterogeneous applications, where the overall throughput
is the main goal. On the contrary, real-time policies are commonly conceived to
reduce it and to meet the time constraint defined for the piece of software.
The solution proposed by Manica et al. in \cite{manica2008qos} consists in limited
changes to the X11 server, making it suitable for real-time applications using
fixed priority scheduling and the Constant Bandwidth Server
(CBS)~\cite{buttazzo2006optimal}. Moreover, talking about real-time graphics and rendering, a lot of work has been
done to develop shading languages. These highly specialized tools
are made available to the developers via high level programming languages
(such as C++ or Java) in order to express graphics operations in the context
of real-time graphics hardware~\cite{Fernando:2003:CTD:862247}. Last but not least,
huge efforts have been done to design a general-purpose system able for high-quality
rendering of complex scenes which is able to deliver 60Hz steady frame
rate~\cite{Montrym:1997:IRG:258734.258871}, but it did not become so popular.

Unfortunately, none of the studies mentioned in this section analyzes the problem
regarding the time guarantees a real-time task has to respect. Furthermore, none of them
examines in depth the performance for web technologies and, more specifically,
for WebGL~\cite{webgl}. Hence, the work presented in this thesis can be considered
a novel approach to real-time analysis applied to the WebGL rendering pipeline,
both from the theoretical and the practical standpoints.

The thesis is divided as follows. Chapter \ref{cha:rt_background}
gives a brief introduction to real-time systems theory in general. Chapter
\ref{cha:tech_stack} describes in detail all the technologies used to build the
3D map navigator powering the FriWalk, the tools that allow to study its
behaviour and a deep explanation of Google Chrome's
inner architecture. Chapter \ref{cha:problem_definition} presents a formal definition
of the problem to be solved. Chapter \ref{cha:rt_model}
explains why a real-time analysis of WebGL is of interest and how the tools
described in Chapter \ref{cha:tech_stack} are used to analyze the test application.
Chapter \ref{cha:experiments} exhaustively explains all the experiments done using
the 3D navigator. Chapter \ref{cha:conclusion} summarizes all the work
done in this thesis and it proposes possible ideas for further developments.
